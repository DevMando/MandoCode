@using MandoCode.Models
@using MandoCode.Services
@using System.Text.RegularExpressions
@using Spectre.Console
@inject AIService AI
@inject MandoCodeConfig Config
@inject TaskPlannerService TaskPlanner
@inject FileAutocompleteProvider FileProvider
@inject TokenTrackingService TokenTracker
@inject MusicPlayerService MusicPlayer
@inject ProjectRootAccessor ProjectRoot
@inject SpinnerService Spinner
@inject OperationDisplayRenderer OperationRenderer
@inject DiffApprovalHandler DiffApproval
@inject ShellCommandHandler Shell
@inject TerminalThemeService ThemeService

<Banner />

<Rows>
    <Markup Content="@($"Project Root: {ProjectRoot.ProjectRoot}")" Background="Color.Black" />
    <Markup Content="@($"Ollama Endpoint: {Config.OllamaEndpoint}")" />
    <Markup Content="@($"Model: {Config.GetEffectiveModelName()}")" />

    @if (!_isConnected)
    {
        LearnContent.Display();
    }
    else if (!string.IsNullOrEmpty(_modelWarning))
    {
        <Panel Border="@BoxBorder.Ascii" BorderColor="Color.Yellow">
            <Rows>
                <Markup Content="@_modelWarning" />
            </Rows>
        </Panel>
    }
    else
    {
        <Markup Content="‚úì MandoCode is ready!" />
        <HelpDisplay />
    }
</Rows>

@code {
    protected bool _isConnected { get; set; } = false;
    private bool _hasRendered = false;
    private string? _modelWarning = null;

    // Last AI response for /copy command
    private string? _lastAiResponse;

    // Cancellation for active AI requests ‚Äî triggered by Ctrl+C
    private CancellationTokenSource? _requestCts;

    // Music visualizer ‚Äî animated equalizer while music plays
    private CancellationTokenSource? _musicVisCts;
    private Task? _musicVisTask;
    private readonly object _musicVisLock = new();



    private void StartMusicVisualizer()
    {
        StopMusicVisualizer();

        if (!MusicPlayer.IsPlaying && !MusicPlayer.IsPaused)
            return;

        ThemeService.IsMusicTitleActive = true;

        var cts = new CancellationTokenSource();
        var token = cts.Token;

        var task = Task.Run(async () =>
        {
            try
            {
                while (!token.IsCancellationRequested)
                {
                    var isPlaying = MusicPlayer.IsPlaying;
                    var trackName = MusicPlayer.CurrentTrack?.Name ?? "Unknown";

                    if (!MusicPlayer.IsPlaying && !MusicPlayer.IsPaused)
                        break;

                    // Animated equalizer in the terminal title bar ‚Äî always visible,
                    // never overlaps scrollback content
                    var eq = isPlaying ? MusicAsciiArt.GetEqualizerFrame() : MusicAsciiArt.GetPausedEqualizerFrame();
                    var note = MusicAsciiArt.GetRandomNote();
                    var stateIcon = isPlaying ? "\u25b6" : "\u23f8";
                    var title = $"{note} {trackName}  {eq}  {stateIcon} MandoCode";
                    Console.Write($"\u001b]0;{title}\u0007");

                    await Task.Delay(isPlaying ? 150 : 500, token);
                }
            }
            catch (OperationCanceledException) { }
            finally
            {
                // Hand title bar back to status display
                try
                {
                    ThemeService.IsMusicTitleActive = false;
                    ThemeService.UpdateStatusTitle();
                }
                catch { }
            }
        });

        lock (_musicVisLock)
        {
            _musicVisCts = cts;
            _musicVisTask = task;
        }
    }

    private void StopMusicVisualizer()
    {
        CancellationTokenSource? cts;
        Task? task;

        lock (_musicVisLock)
        {
            cts = _musicVisCts;
            task = _musicVisTask;
            _musicVisCts = null;
            _musicVisTask = null;
        }

        if (cts != null)
        {
            cts.Cancel();
            if (task != null)
            {
                try { task.Wait(1000); } catch (AggregateException) { }
            }
            cts.Dispose();
        }
    }

    protected override void OnInitialized()
    {
        // Get project root from command line args if available
        var args = Environment.GetCommandLineArgs().Skip(1).ToArray();
        if (args.Length > 0 && !args[0].StartsWith("config"))
        {
            ProjectRoot.ProjectRoot = args[0];
        }

        // Subscribe to function invocation events for UI feedback
        AI.OnFunctionInvoked += OnFunctionInvoked;
        AI.OnFunctionCompleted += OnFunctionCompleted;

        // Wire up diff approval callbacks if enabled
        if (Config.EnableDiffApprovals)
        {
            AI.OnWriteApprovalRequested = DiffApproval.HandleDiffApproval;
            AI.OnDeleteApprovalRequested = DiffApproval.HandleDeleteApproval;
        }

        // Check Ollama connection synchronously ‚Äî render depends on the result
        _isConnected = CheckOllamaConnectionAsync().GetAwaiter().GetResult();

        // Detect terminal theme and apply curated palette
        if (Config.EnableThemeCustomization)
        {
            ThemeService.DetectTheme();
            ThemeService.ApplyPalette();
        }

        // Ctrl+C cancels the active AI request instead of killing the process
        Console.CancelKeyPress += (_, e) =>
        {
            var cts = _requestCts;
            if (cts != null && !cts.IsCancellationRequested)
            {
                e.Cancel = true;   // suppress default process termination
                cts.Cancel();
            }
            else
            {
                // No active request ‚Äî clean up palette before process exits
                ThemeService.ResetPalette();
            }
        };
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && _isConnected && !_hasRendered)
        {
            _hasRendered = true;

            // Initialize file autocomplete
            CommandAutocomplete.Initialize(FileProvider);

            // Validate that model supports function calling
            var (isValid, errorMessage) = await AI.ValidateModelAsync();
            if (!isValid && errorMessage != null)
            {
                // Show warning but allow user to continue
                AnsiConsole.WriteLine();
                AnsiConsole.MarkupLine("[yellow]Warning:[/]");
                AnsiConsole.WriteLine(errorMessage);
                AnsiConsole.WriteLine();

                if (errorMessage.Contains("Continue anyway?"))
                {
                    var continueAnyway = AnsiConsole.Confirm("Continue with this model?", false);
                    if (!continueAnyway)
                    {
                        AnsiConsole.WriteLine("Please configure a supported model:");
                        AnsiConsole.WriteLine("  mandocode config set model qwen2.5-coder:14b");
                        AnsiConsole.WriteLine("  ollama pull qwen2.5-coder:14b");
                        Environment.Exit(1);
                        return;
                    }
                }
                else
                {
                    // Hard error (model not found)
                    _modelWarning = errorMessage;
                    return;
                }
            }

            // Add a small delay to ensure UI is fully rendered
            await Task.Delay(100);
            _ = Task.Run(async () => await RunInteractiveLoopAsync());
        }
    }

    private void OnFunctionInvoked(FunctionCall call)
    {
        // Pause the spinner so the message renders on a clean line
        Spinner.Stop();

        // Suppress display for known FileSystem operations ‚Äî they will be shown
        // as rich operation displays when OnFunctionCompleted fires
        if (!IsFileSystemOperation(call.FunctionName))
        {
            AnsiConsole.MarkupLine($"[dim][[Function]][/] [cyan]{Spectre.Console.Markup.Escape(call.Description)}[/]");
        }

        Spinner.Start();
    }

    private void OnFunctionCompleted(MandoCode.Models.FunctionExecutionResult result)
    {
        // Pause the spinner so the message renders on a clean line
        Spinner.Stop();

        if (result.OperationDisplay != null)
        {
            // Render Claude-Code-style operation display
            OperationRenderer.Render(result.OperationDisplay);
        }
        else if (result.Success)
        {
            AnsiConsole.MarkupLine($"[dim][[Done]][/] [green]‚úì[/]");
        }
        else
        {
            AnsiConsole.MarkupLine($"[dim][[Error]][/] [red]{Spectre.Console.Markup.Escape(result.Result)}[/]");
        }

        // Refresh file cache after any operation that modifies the file system
        var fnLower = result.FunctionName.ToLowerInvariant();
        if (fnLower.Contains("write") || fnLower.Contains("delete") || fnLower.Contains("create") || fnLower.Contains("folder"))
        {
            FileProvider.RefreshCache();
        }

        Spinner.Start();
    }

    /// <summary>
    /// Checks if a function name belongs to the FileSystem plugin.
    /// </summary>
    private bool IsFileSystemOperation(string functionName)
    {
        return functionName.StartsWith("FileSystem_", StringComparison.Ordinal);
    }

    private async Task<bool> CheckOllamaConnectionAsync()
    {
        try
        {
            using var client = new HttpClient { Timeout = TimeSpan.FromSeconds(5) };
            var response = await client.GetAsync($"{Config.OllamaEndpoint}/api/tags");
            return response.IsSuccessStatusCode;
        }
        catch
        {
            return false;
        }
    }

    private async Task RunInteractiveLoopAsync()
    {
        while (true)
        {
            // Show session token count right-aligned above prompt
            if (Config.EnableTokenTracking && TokenTracker.TotalSessionTokens > 0)
            {
                var tokenDisplay = $"Total [{TokenTrackingService.FormatTokenCount(TokenTracker.TotalSessionTokens)} tokens]";
                var padding = Math.Max(0, Console.WindowWidth - tokenDisplay.Length - 1);
                Console.WriteLine($"\u001b[2m{new string(' ', padding)}{tokenDisplay}\u001b[0m");
            }

            // Ensure music visualizer is running if music is active
            // (it writes to a fixed upper-right screen position via ANSI escapes, no prompt conflict)
            StartMusicVisualizer();

            AnsiConsole.Markup("[yellow]> [/]");
            var input = CommandAutocomplete.ReadLineWithAutocomplete();

            if (string.IsNullOrWhiteSpace(input))
                continue;

            // Re-render the submitted input in amber/yellow for old-school terminal feel
            var curTop = Console.CursorTop - 1;
            Console.SetCursorPosition(0, curTop);
            Console.Write($"\u001b[33m> {input}\u001b[0m");
            Console.Write(new string(' ', Math.Max(0, Console.WindowWidth - input.Length - 3)));
            Console.WriteLine();

            // Shell escape: !<cmd> runs a shell command inline
            if (input.TrimStart().StartsWith('!'))
            {
                Shell.HandleShellCommand(input.TrimStart()[1..].Trim());
                continue;
            }

            // Check if this is a command (starts with /)
            if (CommandAutocomplete.IsCommand(input))
            {
                var command = CommandAutocomplete.GetCommandName(input);

                // Handle special commands
                if (command == "exit" || command == "quit")
                {
                    StopMusicVisualizer();
                    MusicPlayer.Dispose();
                    ThemeService.Dispose();
                    AnsiConsole.WriteLine("Goodbye!");
                    Environment.Exit(0);
                    return;
                }

                if (command == "clear")
                {
                    AI.ClearHistory();
                    Console.Clear();
                    AnsiConsole.WriteLine("Conversation cleared.");
                    continue;
                }

                if (command == "help")
                {
                    Console.WriteLine();
                    // Display help (we'll use direct Spectre.Console since HelpDisplay is a component)
                    var table = new Spectre.Console.Table()
                    {
                        Border = TableBorder.Rounded
                    };
                    table.AddColumn("Command");
                    table.AddColumn("Description");
                    table.AddRow("/help", "Show this help message");
                    table.AddRow("/config", "Open configuration menu");
                    table.AddRow("/learn", "Learn about LLMs and local AI models");
                    table.AddRow("/music", "Play lofi/synthwave coding music");
                    table.AddRow("/music-stop", "Stop music playback");
                    table.AddRow("/music-pause", "Pause/resume music");
                    table.AddRow("/music-next", "Skip to next track");
                    table.AddRow("/music-vol", "Set volume (0-100)");
                    table.AddRow("/music-lofi", "Switch to lofi genre");
                    table.AddRow("/music-synthwave", "Switch to synthwave genre");
                    table.AddRow("/music-list", "Show available tracks");
                    table.AddRow("/command", "Run a shell command (also: !<cmd>)");
                    table.AddRow("/copy", "Copy last AI response to clipboard");
                    table.AddRow("/copy-code", "Copy code blocks from last response");
                    table.AddRow("/clear", "Clear conversation history");
                    table.AddRow("/exit, /quit", "Exit MandoCode");
                    AnsiConsole.Write(table);
                    AnsiConsole.WriteLine();
                    AnsiConsole.WriteLine("Examples:");
                    AnsiConsole.WriteLine("  ‚Ä¢ What files are in this project?");
                    AnsiConsole.WriteLine("  ‚Ä¢ Show me the contents of Program.cs");
                    AnsiConsole.WriteLine("  ‚Ä¢ Refactor the Main method to use async/await");
                    AnsiConsole.WriteLine("  ‚Ä¢ What's the current git status?");
                    AnsiConsole.WriteLine();
                    continue;
                }

                if (command == "config")
                {
                    await HandleConfigCommandAsync();
                    continue;
                }

                if (command == "learn")
                {
                    HandleLearnCommand();
                    continue;
                }

                if (command == "copy")
                {
                    HandleCopyCommand();
                    continue;
                }

                if (command == "copy-code")
                {
                    HandleCopyCodeCommand();
                    continue;
                }

                if (command == "rabbit")
                {
                    HandleRabbitCommand();
                    continue;
                }

                // Music commands
                if (command == "music")           { HandleMusicCommand("play"); continue; }
                if (command == "music-stop")      { HandleMusicCommand("stop"); continue; }
                if (command == "music-pause")     { HandleMusicCommand("pause"); continue; }
                if (command == "music-next")      { HandleMusicCommand("next"); continue; }
                if (command == "music-lofi")      { HandleMusicCommand("lofi"); continue; }
                if (command == "music-synthwave") { HandleMusicCommand("synthwave"); continue; }
                if (command == "music-list")      { HandleMusicCommand("list"); continue; }
                if (command.StartsWith("music-vol"))
                {
                    HandleMusicCommand(command);
                    continue;
                }

                if (command == "command" || command.StartsWith("command "))
                {
                    var shellCmd = command.Length > 7 ? command[8..].Trim() : "";
                    Shell.HandleShellCommand(shellCmd);
                    continue;
                }

                // Unknown command
                AnsiConsole.MarkupLine($"[red]Unknown command: {input}[/]");
                AnsiConsole.MarkupLine("[dim]Type /help for available commands[/]");
                AnsiConsole.WriteLine();
                continue;
            }

            // Matrix easter egg: play a cinematic moment for trigger phrases
            if (ContainsMatrixTrigger(input))
            {
                PlayMatrixMoment(input);
            }

            // Check if this request needs task planning BEFORE injecting file content,
            // so that attached file size doesn't inflate the complexity heuristics
            var needsPlanning = TaskPlanner.RequiresPlanning(input);

            // Process @file references and inject file content
            var processedInput = ProcessFileReferences(input);

            if (needsPlanning)
            {
                await HandlePlannedExecutionAsync(processedInput);
                continue;
            }

            // Process AI request with streaming (non-command input)
            await ProcessDirectRequestAsync(processedInput);
        }
    }

    private string ProcessFileReferences(string input)
    {
        var pattern = @"@([\w.\-/\\]+[\w.])";
        var matches = Regex.Matches(input, pattern);

        if (matches.Count == 0)
            return input;

        var contextBlocks = new System.Text.StringBuilder();
        var referencedFiles = new HashSet<string>();

        foreach (Match match in matches)
        {
            var filePath = match.Groups[1].Value;

            // Skip duplicates
            if (!referencedFiles.Add(filePath))
                continue;

            var content = FileProvider.ReadFileContent(filePath);
            if (content != null)
            {
                // Truncate files over 10,000 chars
                if (content.Length > 10_000)
                    content = content.Substring(0, 10_000) + "\n... [truncated]";

                contextBlocks.AppendLine($"File: {filePath}");
                contextBlocks.AppendLine("```");
                contextBlocks.AppendLine(content);
                contextBlocks.AppendLine("```");
                contextBlocks.AppendLine();

                // Track estimated tokens for @file references
                if (Config.EnableTokenTracking)
                {
                    TokenTracker.RecordEstimatedUsage(content.Length, $"@{filePath}");
                }

                AnsiConsole.MarkupLine($"[dim][[Attached]][/] [cyan]{Spectre.Console.Markup.Escape(filePath)}[/]");
            }
            else
            {
                // Check if this is a directory reference
                var dirListing = FileProvider.GetDirectoryListing(filePath);
                if (dirListing != null)
                {
                    contextBlocks.AppendLine($"Directory: {filePath}/");
                    contextBlocks.AppendLine("Contents:");
                    contextBlocks.AppendLine(dirListing);
                    contextBlocks.AppendLine();

                    AnsiConsole.MarkupLine($"[dim][[Directory]][/] [cyan]{Spectre.Console.Markup.Escape(filePath)}/[/]");
                }
                else
                {
                    AnsiConsole.MarkupLine($"[dim][[Not found]][/] [yellow]{Spectre.Console.Markup.Escape(filePath)}[/]");
                }
            }
        }

        if (contextBlocks.Length == 0)
            return input;

        var fullContext = new System.Text.StringBuilder();
        fullContext.AppendLine("--- Referenced Files ---");
        fullContext.Append(contextBlocks);
        fullContext.AppendLine("---");
        fullContext.AppendLine();
        fullContext.Append(input);

        return fullContext.ToString();
    }

    private async Task ProcessDirectRequestAsync(string input)
    {
        AnsiConsole.WriteLine();
        AnsiConsole.MarkupLine("[green]MandoCode:[/]");
        AnsiConsole.WriteLine();

        _requestCts = new CancellationTokenSource();
        var token = _requestCts.Token;

        try
        {
            var receivedFirstChunk = false;
            var enumerator = AI.ChatStreamAsync(input, token).GetAsyncEnumerator(token);

            try
            {
                // Show our controllable spinner while waiting for first chunk
                // This spinner can be stopped by HandleDiffApproval when it needs user input
                Spinner.Start();

                if (await enumerator.MoveNextAsync())
                {
                    receivedFirstChunk = true;
                }

                Spinner.Stop();

                // Buffer all chunks, then render as rich markdown
                if (receivedFirstChunk)
                {
                    var responseBuffer = new System.Text.StringBuilder();
                    var lineBuffer = new System.Text.StringBuilder();
                    var showSpinnerBeforeNextChunk = false;

                    void AccumulateChunk(string chunk)
                    {
                        responseBuffer.Append(chunk);
                        foreach (char c in chunk)
                        {
                            if (c == '\n')
                            {
                                if (lineBuffer.ToString().Contains('\u2699'))
                                    showSpinnerBeforeNextChunk = true;
                                lineBuffer.Clear();
                            }
                            else if (c != '\r')
                            {
                                lineBuffer.Append(c);
                            }
                        }
                    }

                    AccumulateChunk(enumerator.Current);

                    var hasMore = true;
                    while (hasMore)
                    {
                        if (showSpinnerBeforeNextChunk)
                        {
                            showSpinnerBeforeNextChunk = false;
                            Spinner.Start();
                            hasMore = await enumerator.MoveNextAsync();
                            Spinner.Stop();
                        }
                        else
                        {
                            hasMore = await enumerator.MoveNextAsync();
                        }

                        if (hasMore)
                            AccumulateChunk(enumerator.Current);
                    }

                    // Render the complete response as rich markdown
                    var responseText = responseBuffer.ToString().Trim();
                    if (!string.IsNullOrEmpty(responseText))
                    {
                        _lastAiResponse = responseText;

                        try
                        {
                            MarkdownRenderer.Render(responseText);
                        }
                        catch
                        {
                            // Fallback to raw text if markdown rendering fails
                            Console.Write(responseText);
                        }
                    }

                    // Show per-response token summary (right-aligned, tight to response)
                    if (Config.EnableTokenTracking)
                    {
                        var lastOp = TokenTracker.LastOperation;
                        if (lastOp != null && !lastOp.IsEstimate)
                        {
                            var inLabel = $"~{TokenTrackingService.FormatTokenCount(lastOp.PromptTokens)} in";
                            var outLabel = $"{TokenTrackingService.FormatTokenCount(lastOp.CompletionTokens)} out";
                            var tokenSummary = $"[{inLabel}, {outLabel}]";
                            var pad = Math.Max(0, Console.WindowWidth - tokenSummary.Length - 1);
                            Console.WriteLine();
                            Console.WriteLine($"\u001b[2m{new string(' ', pad)}{tokenSummary}\u001b[0m");
                        }
                    }

                    // Update title bar with latest model/project/token info
                    ThemeService.UpdateStatusTitle();
                }
            }
            finally
            {
                Spinner.Stop();
                await enumerator.DisposeAsync();
            }

            AnsiConsole.WriteLine();
        }
        catch (OperationCanceledException)
        {
            Spinner.Stop();
            AnsiConsole.WriteLine();
            AnsiConsole.MarkupLine("[yellow]Request cancelled.[/]");
            AnsiConsole.WriteLine();
        }
        catch (Exception ex)
        {
            Spinner.Stop();
            AnsiConsole.WriteLine($"Error: {ex.Message}");
            AnsiConsole.WriteLine();
        }
        finally
        {
            _requestCts?.Dispose();
            _requestCts = null;
        }
    }

    private async Task HandlePlannedExecutionAsync(string input)
    {
        AnsiConsole.WriteLine();
        AnsiConsole.MarkupLine("[cyan]This looks like a complex request. Creating a plan...[/]");
        AnsiConsole.WriteLine();

        TaskPlan? plan = null;

        // Create the plan with a spinner
        await AnsiConsole.Status()
            .Spinner(LoadingMessages.GetRandomSpinner())
            .StartAsync("Analyzing request and creating plan...", async ctx =>
            {
                plan = await TaskPlanner.CreatePlanAsync(input);
            });

        if (plan == null || plan.Steps.Count == 0)
        {
            AnsiConsole.MarkupLine("[yellow]Could not create a plan. Falling back to direct execution.[/]");
            await ProcessDirectRequestAsync(input);
            return;
        }

        // Display the plan
        DisplayPlan(plan);

        // Ask user to confirm
        var choice = AnsiConsole.Prompt(
            new SelectionPrompt<string>()
                .Title("What would you like to do?")
                .AddChoices(new[] { "Execute plan", "Execute directly (skip planning)", "Cancel" })
        );

        if (choice == "Cancel")
        {
            AnsiConsole.MarkupLine("[dim]Request cancelled.[/]");
            AnsiConsole.WriteLine();
            return;
        }

        if (choice == "Execute directly (skip planning)")
        {
            await ProcessDirectRequestAsync(input);
            return;
        }

        // Execute the plan
        AnsiConsole.WriteLine();
        AnsiConsole.MarkupLine("[green]Executing plan...[/]");
        AnsiConsole.WriteLine();

        await foreach (var progressEvent in TaskPlanner.ExecutePlanAsync(plan))
        {
            await HandleProgressEventAsync(progressEvent, plan);
        }

        // Show summary
        AnsiConsole.WriteLine();
        if (plan.Status == TaskPlanStatus.Completed)
        {
            AnsiConsole.MarkupLine("[green]Plan completed successfully![/]");
        }
        else if (plan.Status == TaskPlanStatus.Cancelled)
        {
            AnsiConsole.MarkupLine("[yellow]Plan was cancelled.[/]");
        }
        else
        {
            AnsiConsole.MarkupLine("[red]Plan completed with errors.[/]");
        }

        if (!string.IsNullOrEmpty(plan.ExecutionSummary))
        {
            AnsiConsole.MarkupLine($"[dim]{Spectre.Console.Markup.Escape(plan.ExecutionSummary)}[/]");
        }
        AnsiConsole.WriteLine();
    }

    private void DisplayPlan(TaskPlan plan)
    {
        var table = new Spectre.Console.Table()
            .Border(TableBorder.Rounded)
            .AddColumn(new TableColumn("Step").Centered())
            .AddColumn(new TableColumn("Description"));

        foreach (var step in plan.Steps)
        {
            table.AddRow(
                $"[cyan]{step.StepNumber}[/]",
                Spectre.Console.Markup.Escape(step.Description)
            );
        }

        AnsiConsole.MarkupLine("[cyan]Created plan:[/]");
        AnsiConsole.WriteLine();
        AnsiConsole.Write(table);
        AnsiConsole.WriteLine();
    }

    private async Task HandleProgressEventAsync(TaskProgressEvent progressEvent, TaskPlan plan)
    {
        switch (progressEvent.ProgressType)
        {
            case TaskProgressType.StepStarted:
                Spinner.Stop();
                SpinnerService.SetTaskbarProgress((progressEvent.CurrentStep - 1) * 100 / progressEvent.TotalSteps);
                AnsiConsole.MarkupLine($"[cyan]Step {progressEvent.CurrentStep}/{progressEvent.TotalSteps}:[/] {Spectre.Console.Markup.Escape(progressEvent.StepDescription)}");
                AnsiConsole.WriteLine();
                break;

            case TaskProgressType.StepCompleted:
                Spinner.Stop();
                SpinnerService.SetTaskbarProgress(progressEvent.CurrentStep * 100 / progressEvent.TotalSteps);
                if (!string.IsNullOrEmpty(progressEvent.Message))
                {
                    // Truncate long results for display
                    var displayMessage = progressEvent.Message.Length > 500
                        ? progressEvent.Message[..500] + "..."
                        : progressEvent.Message;
                    AnsiConsole.Markup(Spectre.Console.Markup.Escape(displayMessage));
                    AnsiConsole.WriteLine();
                }
                AnsiConsole.MarkupLine($"[green]Step {progressEvent.CurrentStep} completed.[/]");
                AnsiConsole.WriteLine();
                break;

            case TaskProgressType.StepFailed:
                Spinner.Stop();
                SpinnerService.SetTaskbarError(progressEvent.CurrentStep * 100 / progressEvent.TotalSteps);
                AnsiConsole.MarkupLine($"[red]Step {progressEvent.CurrentStep} failed:[/] {Spectre.Console.Markup.Escape(progressEvent.Message ?? "Unknown error")}");

                // Ask user what to do
                var failChoice = AnsiConsole.Prompt(
                    new SelectionPrompt<string>()
                        .Title("How would you like to proceed?")
                        .AddChoices(new[] { "Skip this step and continue", "Cancel the plan" })
                );

                if (failChoice == "Cancel the plan")
                {
                    TaskPlanner.CancelPlan(plan);
                }
                else
                {
                    var failedStep = plan.Steps.FirstOrDefault(s => s.StepNumber == progressEvent.CurrentStep);
                    if (failedStep != null)
                    {
                        TaskPlanner.SkipStep(plan, failedStep);
                        SpinnerService.SetTaskbarWarning(progressEvent.CurrentStep * 100 / progressEvent.TotalSteps);
                    }
                }
                break;

            case TaskProgressType.PlanCompleted:
                Spinner.Stop();
                SpinnerService.ClearTaskbarProgress();
                break;

            case TaskProgressType.PlanCancelled:
                Spinner.Stop();
                SpinnerService.ClearTaskbarProgress();
                break;
        }
    }

    private void HandleLearnCommand()
    {
        AnsiConsole.WriteLine();
        LearnContent.Display();

        if (_isConnected)
        {
            var wantChat = AnsiConsole.Confirm("Chat with an AI educator to learn more?", false);
            if (wantChat)
            {
                AI.EnterLearnMode();
                AnsiConsole.WriteLine();
                AnsiConsole.MarkupLine("[green]AI Educator mode active![/]");
                AnsiConsole.MarkupLine("[dim]Ask me anything about local AI! Type /clear to return to normal mode.[/]");
                AnsiConsole.WriteLine();
            }
        }
    }

    private void HandleCopyCommand()
    {
        if (string.IsNullOrEmpty(_lastAiResponse))
        {
            AnsiConsole.MarkupLine("[yellow]Nothing to copy ‚Äî no AI response yet.[/]");
            AnsiConsole.WriteLine();
            return;
        }

        // OSC 52: copy to system clipboard via terminal escape code
        var base64 = Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(_lastAiResponse));
        Console.Write($"\u001b]52;c;{base64}\u0007");

        // Truncate preview for display
        var preview = _lastAiResponse.Length > 80
            ? _lastAiResponse[..77] + "..."
            : _lastAiResponse.Replace("\n", " ");
        AnsiConsole.MarkupLine($"[green]Copied to clipboard[/] [dim]({_lastAiResponse.Length} chars)[/]");
        AnsiConsole.WriteLine();
    }

    private void HandleCopyCodeCommand()
    {
        if (string.IsNullOrEmpty(_lastAiResponse))
        {
            AnsiConsole.MarkupLine("[yellow]Nothing to copy ‚Äî no AI response yet.[/]");
            AnsiConsole.WriteLine();
            return;
        }

        // Extract fenced code blocks
        var codeBlockPattern = @"```(?:\w*)\r?\n([\s\S]*?)```";
        var matches = Regex.Matches(_lastAiResponse, codeBlockPattern);

        if (matches.Count == 0)
        {
            AnsiConsole.MarkupLine("[yellow]No code blocks found in the last response.[/]");
            AnsiConsole.WriteLine();
            return;
        }

        var codeContent = string.Join("\n\n", matches.Cast<Match>().Select(m => m.Groups[1].Value.TrimEnd()));

        // OSC 52 has a practical payload limit (~74,994 bytes base64)
        var base64 = Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(codeContent));
        if (base64.Length > 74_994)
        {
            // Truncate to fit
            var maxBytes = 74_994 * 3 / 4; // approximate raw byte limit
            codeContent = codeContent[..Math.Min(codeContent.Length, maxBytes)];
            base64 = Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(codeContent));
            AnsiConsole.MarkupLine("[yellow]Warning: Code blocks truncated to fit clipboard limit.[/]");
        }

        Console.Write($"\u001b]52;c;{base64}\u0007");

        AnsiConsole.MarkupLine($"[green]Copied {matches.Count} code block(s) to clipboard[/] [dim]({codeContent.Length} chars)[/]");
        AnsiConsole.WriteLine();
    }

    private void HandleRabbitCommand()
    {
        // Katakana-style characters for the digital rain
        var rainChars = "ÔæäÔæêÔæãÔΩ∞ÔΩ≥ÔΩºÔæÖÔæìÔæÜÔΩªÔæúÔæÇÔΩµÔæòÔΩ±ÔæéÔæÉÔæèÔΩπÔæíÔΩ¥ÔΩ∂ÔΩ∑ÔæëÔæïÔæóÔΩæÔæàÔΩΩÔæÄÔæáÔæç012345789:„Éª.\"=*+-<>¬¶‚ïåÍúù";
        var rng = Random.Shared;
        var width = Math.Min(Console.WindowWidth, 120);
        var height = Math.Min(Console.WindowHeight - 2, 24);

        // Each column has a drop position (head of the rain streak)
        var drops = new int[width];
        for (int i = 0; i < width; i++)
            drops[i] = rng.Next(-height, 0); // stagger start positions

        Console.CursorVisible = false;
        Console.Clear();

        // Phase 1: Digital rain (~14 frames)
        for (int frame = 0; frame < 14; frame++)
        {
            var sb = new System.Text.StringBuilder();
            sb.Append("\u001b[H"); // cursor home

            for (int row = 0; row < height; row++)
            {
                for (int col = 0; col < width; col++)
                {
                    int dropPos = drops[col];
                    if (row == dropPos)
                    {
                        // Bright head of the streak
                        sb.Append($"\u001b[97m{rainChars[rng.Next(rainChars.Length)]}\u001b[0m");
                    }
                    else if (row < dropPos && row > dropPos - 6)
                    {
                        // Green trail
                        var fade = dropPos - row;
                        var intensity = fade <= 2 ? "92" : fade <= 4 ? "32" : "2;32";
                        sb.Append($"\u001b[{intensity}m{rainChars[rng.Next(rainChars.Length)]}\u001b[0m");
                    }
                    else
                    {
                        sb.Append(' ');
                    }
                }
                if (row < height - 1) sb.Append('\n');
            }
            Console.Write(sb.ToString());

            // Advance drops
            for (int i = 0; i < width; i++)
            {
                drops[i] += rng.Next(1, 3);
                if (drops[i] > height + 6)
                    drops[i] = rng.Next(-4, 0);
            }

            Thread.Sleep(80);
        }

        // Phase 2: Fade to black, then reveal the rabbit
        Console.Clear();
        Thread.Sleep(300);

        var centerY = height / 2 - 1;
        var rabbit = "üêá";
        var quote = "Follow the white rabbit.";
        var rabbitX = Math.Max(0, (width - 2) / 2);
        var quoteX = Math.Max(0, (width - quote.Length) / 2);

        // Position and print rabbit
        Console.SetCursorPosition(rabbitX, centerY);
        Console.Write(rabbit);

        Thread.Sleep(400);

        // Print quote in green below rabbit
        Console.SetCursorPosition(quoteX, centerY + 2);
        Console.Write($"\u001b[32m{quote}\u001b[0m");

        Thread.Sleep(1500);

        // Clear and return
        Console.Clear();
        Console.CursorVisible = true;
    }

    private static readonly string[] _matrixTriggers =
    {
        "what is the matrix",
        "red pill",
        "follow the white rabbit",
        "there is no spoon"
    };

    private static bool ContainsMatrixTrigger(string input)
    {
        var lower = input.ToLowerInvariant();
        foreach (var trigger in _matrixTriggers)
        {
            if (lower.Contains(trigger))
                return true;
        }
        return false;
    }

    private static void PlayMatrixMoment(string input)
    {
        var lower = input.ToLowerInvariant();
        AnsiConsole.WriteLine();

        if (lower.Contains("what is the matrix"))
        {
            AnsiConsole.MarkupLine("[green]Unfortunately, no one can be told what the Matrix is. You have to see it for yourself.[/]");
            Thread.Sleep(1500);
        }
        else if (lower.Contains("there is no spoon"))
        {
            AnsiConsole.MarkupLine("[green]Then you'll see that it is not the spoon that bends, it is only yourself.[/]");
            Thread.Sleep(1500);
        }
        else if (lower.Contains("red pill"))
        {
            AnsiConsole.MarkupLine("[green]Remember, all I'm offering is the truth. Nothing more.[/]");
            Thread.Sleep(1500);
        }
        else if (lower.Contains("follow the white rabbit"))
        {
            // Small rabbit hopping across the screen
            var width = Math.Min(Console.WindowWidth - 4, 60);
            Console.CursorVisible = false;
            for (int i = 0; i < width; i += 3)
            {
                Console.SetCursorPosition(i, Console.CursorTop);
                Console.Write("  üêá");
                Thread.Sleep(80);
                Console.SetCursorPosition(i, Console.CursorTop);
                Console.Write("    ");
            }
            Console.SetCursorPosition(0, Console.CursorTop);
            Console.CursorVisible = true;
        }

        AnsiConsole.WriteLine();
    }

    private void HandleMusicCommand(string action)
    {
        // Stop visualizer before rendering status panels to avoid flicker
        StopMusicVisualizer();

        // Parse volume from "music-vol 70" style commands
        if (action.StartsWith("music-vol"))
        {
            var parts = action.Split(' ', StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length >= 2 && int.TryParse(parts[1], out var vol))
            {
                MusicPlayer.SetVolume(vol / 100f);
                MusicPlayerUI.RenderStatus(MusicPlayer);
            }
            else
            {
                Console.WriteLine();
                Console.WriteLine("  Usage: /music-vol [0-100]");
                Console.WriteLine("  Example: /music-vol 70");
                Console.WriteLine();
            }
            // Restart visualizer after panel render
            StartMusicVisualizer();
            return;
        }

        switch (action)
        {
            case "play":
                MusicPlayer.Play();
                MusicPlayerUI.RenderStatus(MusicPlayer);
                break;

            case "stop":
                MusicPlayer.Stop();
                MusicPlayerUI.RenderStatus(MusicPlayer);
                break;

            case "pause":
                MusicPlayer.TogglePause();
                MusicPlayerUI.RenderStatus(MusicPlayer);
                break;

            case "next":
                MusicPlayer.NextTrack();
                MusicPlayerUI.RenderStatus(MusicPlayer);
                break;

            case "lofi":
                MusicPlayer.Play("lofi");
                MusicPlayerUI.RenderStatus(MusicPlayer);
                break;

            case "synthwave":
                MusicPlayer.Play("synthwave");
                MusicPlayerUI.RenderStatus(MusicPlayer);
                break;

            case "list":
                MusicPlayerUI.RenderTrackList(MusicPlayer);
                break;
        }

        // Restart visualizer ‚Äî it will auto-check if music is still active
        StartMusicVisualizer();
    }

    private async Task HandleConfigCommandAsync()
    {
        AnsiConsole.WriteLine();
        var choice = AnsiConsole.Prompt(
            new SelectionPrompt<string>()
                .Title("Configuration Options:")
                .AddChoices(new[]
                {
                    "Run configuration wizard",
                    "View current configuration",
                    "Cancel"
                })
        );

        switch (choice)
        {
            case "Run configuration wizard":
                var updatedConfig = await ConfigurationWizard.RunAsync(Config);
                AI.Reinitialize(updatedConfig);
                AnsiConsole.Clear();
                AnsiConsole.WriteLine($"‚úì Configuration updated! Now using model: {updatedConfig.GetEffectiveModelName()}\n");
                break;

            case "View current configuration":
                AnsiConsole.WriteLine();
                Config.Display();
                AnsiConsole.WriteLine();
                break;
        }
    }

}
