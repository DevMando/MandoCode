@using MandoCode.Models
@using MandoCode.Services
@using System.Text.RegularExpressions
@using Spectre.Console
@inject AIService AI
@inject MandoCodeConfig Config
@inject TaskPlannerService TaskPlanner
@inject FileAutocompleteProvider FileProvider

<Banner />

<Rows>
    <Markup Content="@($"Project Root: {_projectRoot}")" Background="Color.Black" />
    <Markup Content="@($"Ollama Endpoint: {Config.OllamaEndpoint}")" />
    <Markup Content="@($"Model: {Config.GetEffectiveModelName()}")" />

    @if (!_isConnected)
    {
        <Panel Border="@BoxBorder.Ascii" BorderColor="Color.Red">
            <Rows>
                <Markup Content="Error: Could not connect to Ollama!" />
                <Markup Content="Please ensure:" />
                <Markup Content="  1. Ollama is installed: https://ollama.ai" />
                <Markup Content="  2. Ollama is running: ollama serve" />
                <Markup Content="@($"  3. Model is installed: ollama pull {Config.GetEffectiveModelName()}")" />
                <Markup Content="" />
                <Markup Content="Or run: mandocode config --help" />
            </Rows>
        </Panel>
    }
    else if (!string.IsNullOrEmpty(_modelWarning))
    {
        <Panel Border="@BoxBorder.Ascii" BorderColor="Color.Yellow">
            <Rows>
                <Markup Content="@_modelWarning" />
            </Rows>
        </Panel>
    }
    else
    {
        <Markup Content="✓ MandoCode is ready!" />
        <HelpDisplay />
    }
</Rows>

@code {
    private string _projectRoot = Environment.CurrentDirectory;
    protected bool _isConnected { get; set; } = false;
    private bool _hasRendered = false;
    private string? _modelWarning = null;

    // Diff approval bypass tracking
    private bool _globalWriteBypass = false;
    private readonly HashSet<string> _approvedFiles = new(StringComparer.OrdinalIgnoreCase);

    // Controllable spinner — can be stopped from the diff approval callback
    private CancellationTokenSource? _spinnerCts;
    private Task? _spinnerTask;
    private readonly object _spinnerLock = new();

    private void StartSpinner()
    {
        StopSpinner();
        var cts = new CancellationTokenSource();
        var token = cts.Token;
        var message = LoadingMessages.GetRandom();
        var frames = new[] { "\u28fb", "\u28fd", "\u28fe", "\u28f7", "\u28ef", "\u28df", "\u28bf", "\u287f" };

        var task = Task.Run(async () =>
        {
            var i = 0;
            try
            {
                while (!token.IsCancellationRequested)
                {
                    var frame = frames[i++ % frames.Length];
                    Console.Write($"\r  {frame} {message}  ");
                    await Task.Delay(80, token);
                }
            }
            catch (OperationCanceledException) { }
            finally
            {
                // Clear the spinner line
                Console.Write($"\r{new string(' ', message.Length + 10)}\r");
            }
        });

        lock (_spinnerLock)
        {
            _spinnerCts = cts;
            _spinnerTask = task;
        }
    }

    private void StopSpinner()
    {
        CancellationTokenSource? cts;
        Task? task;

        lock (_spinnerLock)
        {
            cts = _spinnerCts;
            task = _spinnerTask;
            _spinnerCts = null;
            _spinnerTask = null;
        }

        if (cts != null)
        {
            cts.Cancel();
            task?.Wait(1000);
            cts.Dispose();
        }
    }

    protected override void OnInitialized()
    {
        // Get project root from command line args if available
        var args = Environment.GetCommandLineArgs().Skip(1).ToArray();
        if (args.Length > 0 && !args[0].StartsWith("config"))
        {
            _projectRoot = args[0];
        }

        // Check Ollama connection synchronously to ensure UI is correct
        _isConnected = CheckOllamaConnectionAsync().GetAwaiter().GetResult();

        // Subscribe to function invocation events for UI feedback
        AI.OnFunctionInvoked += OnFunctionInvoked;
        AI.OnFunctionCompleted += OnFunctionCompleted;

        // Wire up diff approval callbacks if enabled
        if (Config.EnableDiffApprovals)
        {
            AI.OnWriteApprovalRequested = HandleDiffApproval;
            AI.OnDeleteApprovalRequested = HandleDeleteApproval;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && _isConnected && !_hasRendered)
        {
            _hasRendered = true;

            // Initialize file autocomplete
            CommandAutocomplete.Initialize(FileProvider);

            // Validate that model supports function calling
            var (isValid, errorMessage) = await AI.ValidateModelAsync();
            if (!isValid && errorMessage != null)
            {
                // Show warning but allow user to continue
                AnsiConsole.WriteLine();
                AnsiConsole.MarkupLine("[yellow]Warning:[/]");
                AnsiConsole.WriteLine(errorMessage);
                AnsiConsole.WriteLine();

                if (errorMessage.Contains("Continue anyway?"))
                {
                    var continueAnyway = AnsiConsole.Confirm("Continue with this model?", false);
                    if (!continueAnyway)
                    {
                        AnsiConsole.WriteLine("Please configure a supported model:");
                        AnsiConsole.WriteLine("  mandocode config set model qwen2.5-coder:14b");
                        AnsiConsole.WriteLine("  ollama pull qwen2.5-coder:14b");
                        Environment.Exit(1);
                        return;
                    }
                }
                else
                {
                    // Hard error (model not found)
                    _modelWarning = errorMessage;
                    return;
                }
            }

            // Add a small delay to ensure UI is fully rendered
            await Task.Delay(100);
            _ = Task.Run(async () => await RunInteractiveLoopAsync());
        }
    }

    private void OnFunctionInvoked(FunctionCall call)
    {
        // Pause the spinner so the message renders on a clean line
        StopSpinner();

        // Suppress display for known FileSystem operations — they will be shown
        // as rich operation displays when OnFunctionCompleted fires
        if (!IsFileSystemOperation(call.FunctionName))
        {
            AnsiConsole.MarkupLine($"[dim][[Function]][/] [cyan]{Spectre.Console.Markup.Escape(call.Description)}[/]");
        }

        StartSpinner();
    }

    private void OnFunctionCompleted(MandoCode.Models.FunctionExecutionResult result)
    {
        // Pause the spinner so the message renders on a clean line
        StopSpinner();

        if (result.OperationDisplay != null)
        {
            // Render Claude-Code-style operation display
            RenderOperationDisplay(result.OperationDisplay);
        }
        else if (result.Success)
        {
            AnsiConsole.MarkupLine($"[dim][[Done]][/] [green]✓[/]");
        }
        else
        {
            AnsiConsole.MarkupLine($"[dim][[Error]][/] [red]{Spectre.Console.Markup.Escape(result.Result)}[/]");
        }

        // Refresh file cache after write/delete operations so @ autocomplete stays current
        var fnLower = result.FunctionName.ToLowerInvariant();
        if (fnLower.Contains("write") || fnLower.Contains("delete"))
        {
            FileProvider.RefreshCache();
        }

        StartSpinner();
    }

    /// <summary>
    /// Checks if a function name belongs to the FileSystem plugin.
    /// </summary>
    private bool IsFileSystemOperation(string functionName)
    {
        return functionName.StartsWith("FileSystem_", StringComparison.Ordinal);
    }

    /// <summary>
    /// Renders a Claude-Code-style operation display with tree connectors,
    /// content previews, and inline diffs.
    /// </summary>
    private void RenderOperationDisplay(OperationDisplayEvent e)
    {
        Console.WriteLine();

        switch (e.OperationType)
        {
            case "Write":
                RenderWriteDisplay(e);
                break;

            case "Update":
                RenderUpdateDisplay(e);
                break;

            case "Read":
                Console.WriteLine($"\u001b[1m● Read(\u001b[0m{e.FilePath}\u001b[1m)\u001b[0m");
                Console.WriteLine($"  ⎿  \u001b[2mRead {e.LineCount} lines\u001b[0m");
                break;

            case "Delete":
                Console.WriteLine($"\u001b[1m● Delete(\u001b[0m{e.FilePath}\u001b[1m)\u001b[0m");
                Console.WriteLine($"  ⎿  \u001b[2mDeleted {e.LineCount} lines\u001b[0m");
                break;

            case "DeleteFolder":
                Console.WriteLine($"\u001b[1m● DeleteFolder(\u001b[0m{e.FilePath}\u001b[1m)\u001b[0m");
                Console.WriteLine($"  ⎿  \u001b[2mDeleted folder and all contents\u001b[0m");
                break;

            case "CreateFolder":
                Console.WriteLine($"\u001b[1m● CreateFolder(\u001b[0m{e.FilePath}\u001b[1m)\u001b[0m");
                Console.WriteLine($"  ⎿  \u001b[2mCreated directory\u001b[0m");
                break;

            case "List":
                Console.WriteLine($"\u001b[2m● Listed project files\u001b[0m");
                break;

            case "Glob":
                Console.WriteLine($"\u001b[2m● Glob(\u001b[0m{e.FilePath}\u001b[2m)\u001b[0m");
                break;

            case "Search":
                Console.WriteLine($"\u001b[2m● Search(\u001b[0m\"{e.FilePath}\"\u001b[2m)\u001b[0m");
                break;
        }
    }

    /// <summary>
    /// Renders a new file write: header, line count, content preview, remaining lines.
    /// </summary>
    private void RenderWriteDisplay(OperationDisplayEvent e)
    {
        Console.WriteLine($"\u001b[1m● Write(\u001b[0m{e.FilePath}\u001b[1m)\u001b[0m");
        Console.WriteLine($"  ⎿  \u001b[2mWrote {e.LineCount} lines to {e.FilePath}\u001b[0m");

        // Show content preview unless the user already reviewed the diff via approval
        if (!e.ApprovalWasShown && !string.IsNullOrEmpty(e.ContentPreview))
        {
            foreach (var line in e.ContentPreview.Split('\n'))
            {
                var display = line.Length > 120 ? line[..120] + "..." : line;
                Console.WriteLine($"\u001b[2m     {display}\u001b[0m");
            }

            if (e.RemainingLines > 0)
            {
                Console.WriteLine($"\u001b[2m     … +{e.RemainingLines} lines\u001b[0m");
            }
        }
    }

    /// <summary>
    /// Renders an update to an existing file: header, change summary, inline diff.
    /// </summary>
    private void RenderUpdateDisplay(OperationDisplayEvent e)
    {
        Console.WriteLine($"\u001b[1m● Update(\u001b[0m{e.FilePath}\u001b[1m)\u001b[0m");

        // Build summary line: "Added N lines" / "Removed N lines" / "Added N, removed M lines"
        var parts = new List<string>();
        if (e.Additions > 0) parts.Add($"Added {e.Additions} line{(e.Additions != 1 ? "s" : "")}");
        if (e.Deletions > 0) parts.Add($"Removed {e.Deletions} line{(e.Deletions != 1 ? "s" : "")}");
        Console.WriteLine($"  ⎿  \u001b[2m{string.Join(", ", parts)}\u001b[0m");

        // Show inline diff unless the user already reviewed via approval
        if (!e.ApprovalWasShown && e.InlineDiff != null)
        {
            foreach (var d in e.InlineDiff)
            {
                var num = (d.NewLineNumber ?? d.OldLineNumber)?.ToString() ?? "";
                var padNum = num.PadLeft(4);
                var content = d.Content.Length > 120 ? d.Content[..120] + "..." : d.Content;

                switch (d.LineType)
                {
                    case DiffLineType.Added:
                        Console.WriteLine($"\u001b[32m      {padNum} + {content}\u001b[0m");
                        break;
                    case DiffLineType.Removed:
                        Console.WriteLine($"\u001b[31m      {padNum} - {content}\u001b[0m");
                        break;
                    case DiffLineType.Unchanged:
                        Console.WriteLine($"\u001b[2m      {padNum}   {content}\u001b[0m");
                        break;
                }
            }
        }
    }

    private async Task<bool> CheckOllamaConnectionAsync()
    {
        try
        {
            using var client = new HttpClient { Timeout = TimeSpan.FromSeconds(5) };
            var response = await client.GetAsync($"{Config.OllamaEndpoint}/api/tags");
            return response.IsSuccessStatusCode;
        }
        catch
        {
            return false;
        }
    }

    private async Task RunInteractiveLoopAsync()
    {
        while (true)
        {
            AnsiConsole.Markup("You: ");
            var input = CommandAutocomplete.ReadLineWithAutocomplete();

            if (string.IsNullOrWhiteSpace(input))
                continue;

            // Check if this is a command (starts with /)
            if (CommandAutocomplete.IsCommand(input))
            {
                var command = CommandAutocomplete.GetCommandName(input);

                // Handle special commands
                if (command == "exit" || command == "quit")
                {
                    AnsiConsole.WriteLine("Goodbye!");
                    Environment.Exit(0);
                    return;
                }

                if (command == "clear")
                {
                    AI.ClearHistory();
                    Console.Clear();
                    AnsiConsole.WriteLine("Conversation cleared.");
                    continue;
                }

                if (command == "help")
                {
                    Console.WriteLine();
                    // Display help (we'll use direct Spectre.Console since HelpDisplay is a component)
                    var table = new Spectre.Console.Table()
                    {
                        Border = TableBorder.Rounded
                    };
                    table.AddColumn("Command");
                    table.AddColumn("Description");
                    table.AddRow("/help", "Show this help message");
                    table.AddRow("/config", "Open configuration menu");
                    table.AddRow("/clear", "Clear conversation history");
                    table.AddRow("/exit, /quit", "Exit MandoCode");
                    table.AddRow("anything else", "Chat with the AI assistant");
                    AnsiConsole.Write(table);
                    AnsiConsole.WriteLine();
                    AnsiConsole.WriteLine("Examples:");
                    AnsiConsole.WriteLine("  • What files are in this project?");
                    AnsiConsole.WriteLine("  • Show me the contents of Program.cs");
                    AnsiConsole.WriteLine("  • Refactor the Main method to use async/await");
                    AnsiConsole.WriteLine("  • What's the current git status?");
                    AnsiConsole.WriteLine();
                    continue;
                }

                if (command == "config")
                {
                    await HandleConfigCommandAsync();
                    continue;
                }

                // Unknown command
                AnsiConsole.MarkupLine($"[red]Unknown command: {input}[/]");
                AnsiConsole.MarkupLine("[dim]Type /help for available commands[/]");
                AnsiConsole.WriteLine();
                continue;
            }

            // Check if this request needs task planning BEFORE injecting file content,
            // so that attached file size doesn't inflate the complexity heuristics
            var needsPlanning = TaskPlanner.RequiresPlanning(input);

            // Process @file references and inject file content
            var processedInput = ProcessFileReferences(input);

            if (needsPlanning)
            {
                await HandlePlannedExecutionAsync(processedInput);
                continue;
            }

            // Process AI request with streaming (non-command input)
            await ProcessDirectRequestAsync(processedInput);
        }
    }

    private string ProcessFileReferences(string input)
    {
        var pattern = @"@([\w.\-/\\]+[\w.])";
        var matches = Regex.Matches(input, pattern);

        if (matches.Count == 0)
            return input;

        var contextBlocks = new System.Text.StringBuilder();
        var referencedFiles = new HashSet<string>();

        foreach (Match match in matches)
        {
            var filePath = match.Groups[1].Value;

            // Skip duplicates
            if (!referencedFiles.Add(filePath))
                continue;

            var content = FileProvider.ReadFileContent(filePath);
            if (content != null)
            {
                // Truncate files over 10,000 chars
                if (content.Length > 10_000)
                    content = content.Substring(0, 10_000) + "\n... [truncated]";

                contextBlocks.AppendLine($"File: {filePath}");
                contextBlocks.AppendLine("```");
                contextBlocks.AppendLine(content);
                contextBlocks.AppendLine("```");
                contextBlocks.AppendLine();

                AnsiConsole.MarkupLine($"[dim][[Attached]][/] [cyan]{Spectre.Console.Markup.Escape(filePath)}[/]");
            }
            else
            {
                // Check if this is a directory reference
                var dirListing = FileProvider.GetDirectoryListing(filePath);
                if (dirListing != null)
                {
                    contextBlocks.AppendLine($"Directory: {filePath}/");
                    contextBlocks.AppendLine("Contents:");
                    contextBlocks.AppendLine(dirListing);
                    contextBlocks.AppendLine();

                    AnsiConsole.MarkupLine($"[dim][[Directory]][/] [cyan]{Spectre.Console.Markup.Escape(filePath)}/[/]");
                }
                else
                {
                    AnsiConsole.MarkupLine($"[dim][[Not found]][/] [yellow]{Spectre.Console.Markup.Escape(filePath)}[/]");
                }
            }
        }

        if (contextBlocks.Length == 0)
            return input;

        var fullContext = new System.Text.StringBuilder();
        fullContext.AppendLine("--- Referenced Files ---");
        fullContext.Append(contextBlocks);
        fullContext.AppendLine("---");
        fullContext.AppendLine();
        fullContext.Append(input);

        return fullContext.ToString();
    }

    private async Task ProcessDirectRequestAsync(string input)
    {
        AnsiConsole.WriteLine();
        AnsiConsole.MarkupLine("[green]MandoCode:[/]");
        AnsiConsole.WriteLine();

        try
        {
            var receivedFirstChunk = false;
            var enumerator = AI.ChatStreamAsync(input).GetAsyncEnumerator();

            try
            {
                // Show our controllable spinner while waiting for first chunk
                // This spinner can be stopped by HandleDiffApproval when it needs user input
                StartSpinner();

                if (await enumerator.MoveNextAsync())
                {
                    receivedFirstChunk = true;
                }

                StopSpinner();

                // Buffer all chunks, then render as rich markdown
                if (receivedFirstChunk)
                {
                    var responseBuffer = new System.Text.StringBuilder();
                    var lineBuffer = new System.Text.StringBuilder();
                    var showSpinnerBeforeNextChunk = false;

                    void AccumulateChunk(string chunk)
                    {
                        responseBuffer.Append(chunk);
                        foreach (char c in chunk)
                        {
                            if (c == '\n')
                            {
                                if (lineBuffer.ToString().Contains('\u2699'))
                                    showSpinnerBeforeNextChunk = true;
                                lineBuffer.Clear();
                            }
                            else if (c != '\r')
                            {
                                lineBuffer.Append(c);
                            }
                        }
                    }

                    AccumulateChunk(enumerator.Current);

                    var hasMore = true;
                    while (hasMore)
                    {
                        if (showSpinnerBeforeNextChunk)
                        {
                            showSpinnerBeforeNextChunk = false;
                            StartSpinner();
                            hasMore = await enumerator.MoveNextAsync();
                            StopSpinner();
                        }
                        else
                        {
                            hasMore = await enumerator.MoveNextAsync();
                        }

                        if (hasMore)
                            AccumulateChunk(enumerator.Current);
                    }

                    // Render the complete response as rich markdown
                    var responseText = responseBuffer.ToString().Trim();
                    if (!string.IsNullOrEmpty(responseText))
                    {
                        try
                        {
                            MarkdownRenderer.Render(responseText);
                        }
                        catch
                        {
                            // Fallback to raw text if markdown rendering fails
                            Console.Write(responseText);
                        }
                    }
                }
            }
            finally
            {
                StopSpinner();
                await enumerator.DisposeAsync();
            }

            AnsiConsole.WriteLine();
            AnsiConsole.WriteLine();
        }
        catch (Exception ex)
        {
            StopSpinner();
            AnsiConsole.WriteLine($"Error: {ex.Message}");
            AnsiConsole.WriteLine();
        }
    }

    private async Task HandlePlannedExecutionAsync(string input)
    {
        AnsiConsole.WriteLine();
        AnsiConsole.MarkupLine("[cyan]This looks like a complex request. Creating a plan...[/]");
        AnsiConsole.WriteLine();

        TaskPlan? plan = null;

        // Create the plan with a spinner
        await AnsiConsole.Status()
            .Spinner(LoadingMessages.GetRandomSpinner())
            .StartAsync("Analyzing request and creating plan...", async ctx =>
            {
                plan = await TaskPlanner.CreatePlanAsync(input);
            });

        if (plan == null || plan.Steps.Count == 0)
        {
            AnsiConsole.MarkupLine("[yellow]Could not create a plan. Falling back to direct execution.[/]");
            await ProcessDirectRequestAsync(input);
            return;
        }

        // Display the plan
        DisplayPlan(plan);

        // Ask user to confirm
        var choice = AnsiConsole.Prompt(
            new SelectionPrompt<string>()
                .Title("What would you like to do?")
                .AddChoices(new[] { "Execute plan", "Execute directly (skip planning)", "Cancel" })
        );

        if (choice == "Cancel")
        {
            AnsiConsole.MarkupLine("[dim]Request cancelled.[/]");
            AnsiConsole.WriteLine();
            return;
        }

        if (choice == "Execute directly (skip planning)")
        {
            await ProcessDirectRequestAsync(input);
            return;
        }

        // Execute the plan
        AnsiConsole.WriteLine();
        AnsiConsole.MarkupLine("[green]Executing plan...[/]");
        AnsiConsole.WriteLine();

        await foreach (var progressEvent in TaskPlanner.ExecutePlanAsync(plan))
        {
            await HandleProgressEventAsync(progressEvent, plan);
        }

        // Show summary
        AnsiConsole.WriteLine();
        if (plan.Status == TaskPlanStatus.Completed)
        {
            AnsiConsole.MarkupLine("[green]Plan completed successfully![/]");
        }
        else if (plan.Status == TaskPlanStatus.Cancelled)
        {
            AnsiConsole.MarkupLine("[yellow]Plan was cancelled.[/]");
        }
        else
        {
            AnsiConsole.MarkupLine("[red]Plan completed with errors.[/]");
        }

        if (!string.IsNullOrEmpty(plan.ExecutionSummary))
        {
            AnsiConsole.MarkupLine($"[dim]{Spectre.Console.Markup.Escape(plan.ExecutionSummary)}[/]");
        }
        AnsiConsole.WriteLine();
    }

    private void DisplayPlan(TaskPlan plan)
    {
        var table = new Spectre.Console.Table()
            .Border(TableBorder.Rounded)
            .AddColumn(new TableColumn("Step").Centered())
            .AddColumn(new TableColumn("Description"));

        foreach (var step in plan.Steps)
        {
            table.AddRow(
                $"[cyan]{step.StepNumber}[/]",
                Spectre.Console.Markup.Escape(step.Description)
            );
        }

        AnsiConsole.MarkupLine("[cyan]Created plan:[/]");
        AnsiConsole.WriteLine();
        AnsiConsole.Write(table);
        AnsiConsole.WriteLine();
    }

    private async Task HandleProgressEventAsync(TaskProgressEvent progressEvent, TaskPlan plan)
    {
        switch (progressEvent.ProgressType)
        {
            case TaskProgressType.StepStarted:
                StopSpinner();
                AnsiConsole.MarkupLine($"[cyan]Step {progressEvent.CurrentStep}/{progressEvent.TotalSteps}:[/] {Spectre.Console.Markup.Escape(progressEvent.StepDescription)}");
                AnsiConsole.WriteLine();
                break;

            case TaskProgressType.StepCompleted:
                StopSpinner();
                if (!string.IsNullOrEmpty(progressEvent.Message))
                {
                    // Truncate long results for display
                    var displayMessage = progressEvent.Message.Length > 500
                        ? progressEvent.Message[..500] + "..."
                        : progressEvent.Message;
                    AnsiConsole.Markup(Spectre.Console.Markup.Escape(displayMessage));
                    AnsiConsole.WriteLine();
                }
                AnsiConsole.MarkupLine($"[green]Step {progressEvent.CurrentStep} completed.[/]");
                AnsiConsole.WriteLine();
                break;

            case TaskProgressType.StepFailed:
                StopSpinner();
                AnsiConsole.MarkupLine($"[red]Step {progressEvent.CurrentStep} failed:[/] {Spectre.Console.Markup.Escape(progressEvent.Message ?? "Unknown error")}");

                // Ask user what to do
                var failChoice = AnsiConsole.Prompt(
                    new SelectionPrompt<string>()
                        .Title("How would you like to proceed?")
                        .AddChoices(new[] { "Skip this step and continue", "Cancel the plan" })
                );

                if (failChoice == "Cancel the plan")
                {
                    TaskPlanner.CancelPlan(plan);
                }
                else
                {
                    var failedStep = plan.Steps.FirstOrDefault(s => s.StepNumber == progressEvent.CurrentStep);
                    if (failedStep != null)
                    {
                        TaskPlanner.SkipStep(plan, failedStep);
                    }
                }
                break;

            case TaskProgressType.PlanCompleted:
                StopSpinner();
                break;

            case TaskProgressType.PlanCancelled:
                StopSpinner();
                break;
        }
    }

    private async Task HandleConfigCommandAsync()
    {
        AnsiConsole.WriteLine();
        var choice = AnsiConsole.Prompt(
            new SelectionPrompt<string>()
                .Title("Configuration Options:")
                .AddChoices(new[]
                {
                    "Run configuration wizard",
                    "View current configuration",
                    "Cancel"
                })
        );

        switch (choice)
        {
            case "Run configuration wizard":
                var updatedConfig = await ConfigurationWizard.RunAsync(Config);
                AI.Reinitialize(updatedConfig);
                AnsiConsole.Clear();
                AnsiConsole.WriteLine($"✓ Configuration updated! Now using model: {updatedConfig.GetEffectiveModelName()}\n");
                break;

            case "View current configuration":
                AnsiConsole.WriteLine();
                Config.Display();
                AnsiConsole.WriteLine();
                break;
        }
    }

    private void RenderDiffPanel(string relativePath, List<DiffLine> displayLines, int additions, int deletions, bool isNewFile)
    {
        Console.WriteLine();

        var header = $"\u250c\u2500 Diff: {relativePath} ";
        var padLen = Math.Max(0, 50 - header.Length);
        Console.WriteLine(header + new string('\u2500', padLen) + "\u2510");
        Console.WriteLine("\u2502");

        foreach (var line in displayLines)
        {
            var lineNum = "";

            switch (line.LineType)
            {
                case DiffLineType.Removed:
                    lineNum = line.OldLineNumber.HasValue ? $"{line.OldLineNumber,4}" : "    ";
                    Console.Write("\u2502 ");
                    Console.Write($"\u001b[31m{lineNum} - {line.Content}\u001b[0m");
                    Console.WriteLine();
                    break;

                case DiffLineType.Added:
                    lineNum = line.NewLineNumber.HasValue ? $"{line.NewLineNumber,4}" : "    ";
                    Console.Write("\u2502 ");
                    Console.Write($"\u001b[38;2;135;206;250m{lineNum} + {line.Content}\u001b[0m");
                    Console.WriteLine();
                    break;

                case DiffLineType.Unchanged:
                    lineNum = line.OldLineNumber.HasValue ? $"{line.OldLineNumber,4}" : "    ";
                    Console.Write("\u2502 ");
                    Console.Write($"\u001b[2m{lineNum}   {line.Content}\u001b[0m");
                    Console.WriteLine();
                    break;
            }
        }

        Console.WriteLine("\u2502");
        var fileLabel = isNewFile ? " (new file)" : "";
        Console.WriteLine($"\u2502  {deletions} deletion(s), {additions} addition(s){fileLabel}");
        Console.WriteLine("\u2514" + new string('\u2500', Math.Max(padLen + header.Length - 1, 40)) + "\u2518");
        Console.WriteLine();
    }

    private Task<DiffApprovalResult> HandleDiffApproval(string relativePath, string? oldContent, string newContent)
    {
        // Stop the spinner so we have clean console output
        StopSpinner();

        // Compute diff
        var diffLines = DiffService.ComputeDiff(oldContent, newContent);
        var isNewFile = oldContent == null;
        var displayLines = DiffService.CollapseContext(diffLines, 3);
        var additions = diffLines.Count(l => l.LineType == DiffLineType.Added);
        var deletions = diffLines.Count(l => l.LineType == DiffLineType.Removed);
        var fileName = Path.GetFileName(relativePath);

        // Always show the diff so the user can see what's changing
        RenderDiffPanel(relativePath, displayLines, additions, deletions, isNewFile);

        // If globally bypassed or this file is already approved, auto-approve without prompting
        if (_globalWriteBypass || _approvedFiles.Contains(relativePath))
        {
            AnsiConsole.MarkupLine($"[green]\u2713 Auto-approved[/]");
            AnsiConsole.WriteLine();
            StartSpinner();
            return Task.FromResult(new DiffApprovalResult { Response = DiffApprovalResponse.Approved });
        }

        // Build choices for the SelectionPrompt — now safe since our spinner is stopped
        var noAskLabel = isNewFile
            ? "Approve - okay to write & modify files don't ask me again"
            : $"Approve - Don't ask again to modify {fileName}";

        var approvalChoice = AnsiConsole.Prompt(
            new SelectionPrompt<string>()
                .Title("[cyan]Apply these changes?[/]")
                .AddChoices(new[]
                {
                    "Approve",
                    noAskLabel,
                    "Deny",
                    "Provide new instructions"
                })
        );

        DiffApprovalResult result;

        if (approvalChoice == "Approve")
        {
            AnsiConsole.MarkupLine("[green]Changes approved.[/]");
            result = new DiffApprovalResult { Response = DiffApprovalResponse.Approved };
        }
        else if (approvalChoice == noAskLabel)
        {
            AnsiConsole.MarkupLine("[green]Changes approved.[/]");
            if (isNewFile)
            {
                _globalWriteBypass = true;
                AnsiConsole.MarkupLine("[dim]All future writes will be auto-approved for this session.[/]");
            }
            else
            {
                _approvedFiles.Add(relativePath);
                AnsiConsole.MarkupLine($"[dim]Future modifications to {Spectre.Console.Markup.Escape(fileName)} will be auto-approved.[/]");
            }
            result = new DiffApprovalResult { Response = DiffApprovalResponse.ApprovedNoAskAgain };
        }
        else if (approvalChoice == "Deny")
        {
            AnsiConsole.MarkupLine("[red]Changes denied.[/]");
            result = new DiffApprovalResult { Response = DiffApprovalResponse.Denied };
        }
        else // "Provide new instructions"
        {
            var instructions = AnsiConsole.Prompt(
                new TextPrompt<string>("[yellow]Enter your instructions:[/]")
            );
            AnsiConsole.MarkupLine("[yellow]Redirecting with new instructions...[/]");
            result = new DiffApprovalResult
            {
                Response = DiffApprovalResponse.NewInstructions,
                UserMessage = instructions
            };
        }

        AnsiConsole.WriteLine();

        // Resume spinner for the rest of the AI call
        StartSpinner();

        return Task.FromResult(result);
    }

    private Task<DiffApprovalResult> HandleDeleteApproval(string relativePath, string? existingContent)
    {
        // Stop the spinner so we have clean console output
        StopSpinner();

        var fileName = Path.GetFileName(relativePath);
        var isFolder = existingContent != null && existingContent.StartsWith("Folder:");

        if (isFolder)
        {
            // Folder deletion — show folder listing instead of diff
            Console.WriteLine();
            Console.WriteLine($"\u001b[31m┌─ Delete Folder: {relativePath}/ ─────────────────────┐\u001b[0m");
            Console.WriteLine("\u001b[31m│\u001b[0m");
            foreach (var line in existingContent!.Split('\n'))
            {
                Console.WriteLine($"\u001b[31m│ {line}\u001b[0m");
            }
            Console.WriteLine("\u001b[31m│\u001b[0m");
            Console.WriteLine($"\u001b[31m└──────────────────────────────────────────────────┘\u001b[0m");
            Console.WriteLine();
            AnsiConsole.MarkupLine($"[red]This will DELETE the folder and ALL its contents: {Spectre.Console.Markup.Escape(relativePath)}/[/]");
            Console.WriteLine();
        }
        else
        {
            // File deletion — show diff as before
            var diffLines = new List<DiffLine>();
            if (!string.IsNullOrEmpty(existingContent))
            {
                var lines = existingContent.Split('\n');
                for (int i = 0; i < lines.Length; i++)
                {
                    diffLines.Add(new DiffLine
                    {
                        LineType = DiffLineType.Removed,
                        Content = lines[i].TrimEnd('\r'),
                        OldLineNumber = i + 1
                    });
                }
            }

            var deletions = diffLines.Count;
            var displayLines = DiffService.CollapseContext(diffLines, 3);

            RenderDiffPanel(relativePath, displayLines, 0, deletions, false);
            AnsiConsole.MarkupLine($"[red]This will DELETE the file: {Spectre.Console.Markup.Escape(relativePath)}[/]");
            Console.WriteLine();
        }

        // If globally bypassed, auto-approve
        if (_globalWriteBypass)
        {
            AnsiConsole.MarkupLine($"[green]✓ Auto-approved deletion[/]");
            AnsiConsole.WriteLine();
            StartSpinner();
            return Task.FromResult(new DiffApprovalResult { Response = DiffApprovalResponse.Approved });
        }

        var approvalChoice = AnsiConsole.Prompt(
            new SelectionPrompt<string>()
                .Title("[cyan]Delete this file?[/]")
                .AddChoices(new[]
                {
                    "Approve deletion",
                    "Approve - okay to write, modify & delete files don't ask me again",
                    "Deny",
                    "Provide new instructions"
                })
        );

        DiffApprovalResult result;

        if (approvalChoice == "Approve deletion")
        {
            AnsiConsole.MarkupLine("[green]Deletion approved.[/]");
            result = new DiffApprovalResult { Response = DiffApprovalResponse.Approved };
        }
        else if (approvalChoice.StartsWith("Approve - okay"))
        {
            AnsiConsole.MarkupLine("[green]Deletion approved.[/]");
            _globalWriteBypass = true;
            AnsiConsole.MarkupLine("[dim]All future writes and deletions will be auto-approved for this session.[/]");
            result = new DiffApprovalResult { Response = DiffApprovalResponse.ApprovedNoAskAgain };
        }
        else if (approvalChoice == "Deny")
        {
            AnsiConsole.MarkupLine("[red]Deletion denied.[/]");
            result = new DiffApprovalResult { Response = DiffApprovalResponse.Denied };
        }
        else // "Provide new instructions"
        {
            var instructions = AnsiConsole.Prompt(
                new TextPrompt<string>("[yellow]Enter your instructions:[/]")
            );
            AnsiConsole.MarkupLine("[yellow]Redirecting with new instructions...[/]");
            result = new DiffApprovalResult
            {
                Response = DiffApprovalResponse.NewInstructions,
                UserMessage = instructions
            };
        }

        AnsiConsole.WriteLine();

        // Resume spinner for the rest of the AI call
        StartSpinner();

        return Task.FromResult(result);
    }
}
